#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Thu Dec  4 18:39:05 2025@author: dyfanrhys"""### --- Project Module Imports --- ###import gpx_toolimport physics_engineimport optimizerimport timeimport jsonimport statisticsimport matplotlib.pyplot as pltfrom matplotlib.ticker import MultipleLocatorfrom typing import Tuple, List, DictDEBUG_WIND_PRINTS = False # Set to True to protect against large files. Set to False for maximum precision.USE_SMART_DOWNSAMPLING = Truedef plot_segments_on_profile(gpx_track_points: List[Dict], gpx_to_opt_segment_map: List[int], course_name: str, fig_name: str = 'segmented_elevation_profile_pre_opt.png'):    if not gpx_track_points or not gpx_to_opt_segment_map:        print("Warning: Cannot plot segments without data.")        return    distances_km = [p['cumulativeDistanceM'] / 1000.0 for p in gpx_track_points]    smoothed_elevations = [p['smoothedElevation'] for p in gpx_track_points]    fig, ax1 = plt.subplots(figsize=(15, 6))    ax1.plot(distances_km, smoothed_elevations, label='Smoothed Elevation', color='blue')    ax1.set_xlabel('Distance (km)')    ax1.set_ylabel('Elevation (m)', color='blue')    ax1.tick_params(axis='y', labelcolor='blue')    ax1.grid(True, linestyle='--', alpha=0.6)        segment_start_indices = [0]         for i in range(1, len(gpx_to_opt_segment_map)):        if gpx_to_opt_segment_map[i] != gpx_to_opt_segment_map[i-1]:            segment_start_indices.append(i)    for index in segment_start_indices:        segment_dist_km = distances_km[index]        ax1.axvline(x=segment_dist_km, color='red', linestyle='--', alpha=0.7, linewidth=1.5)    ax1.set_title(f'Segmented Elevation Profile for {course_name} (Pre-Optimization)')    plt.tight_layout()    ax = plt.gca()     ax.xaxis.set_major_locator(MultipleLocator(50))     ax.xaxis.set_minor_locator(MultipleLocator(10))     plt.show()    print(f"\n--- Displaying Segmented Elevation Profile Plot (File: {fig_name}) ---")def plot_performance_profile(simulation_log: List[Dict], title: str):    if not simulation_log:        print(f"Warning: No log data available for {title}")        return    distances_km = [entry['distance'] for entry in simulation_log]    powers = [entry['power'] for entry in simulation_log]    elevations = [entry['elevation'] for entry in simulation_log]    fig, ax1 = plt.subplots(figsize=(14, 7))    plt.title(f'{title} - Performance Analysis')    color_power = 'tab:red'    ax1.set_xlabel('Distance (km)', fontsize=12)    ax1.set_ylabel('Power (Watts)', color=color_power, fontsize=12)    y1_limit_max = max(powers)+(max(powers)*0.1)    ax1.set_ylim(0, y1_limit_max)    ax1.plot(distances_km, powers, color=color_power, linewidth=1.5, label='Power', alpha=0.9)    ax1.tick_params(axis='y', labelcolor=color_power)    ax1.grid(True, which='major', linestyle='--', alpha=0.5)    ax2 = ax1.twinx()          color_grade = 'tab:green'    ax2.set_ylabel('Elevation (m)', color=color_grade, fontsize=12)    y2_limit_min = min(elevations)-(min(elevations)*0.4)    y2_limit_max = max(elevations)+(max(elevations)*0.1)        ax2.set_ylim(100, y2_limit_max)        ax2.fill_between(distances_km, elevations, 0, color=color_grade, alpha=0.2, label='Grade Area')    ax2.plot(distances_km, elevations, color=color_grade, linewidth=1.0, linestyle=':', label='Grade')    ax2.tick_params(axis='y', labelcolor=color_grade)    fig.tight_layout()    print(f"--- Displaying Performance Profile: {title} ---")    plt.show()def plot_comparative_performance(log_baseline: List[Dict], log_optimized: List[Dict], course_name: str):    if not log_baseline or not log_optimized:        print("Warning: Insufficient data for comparative plot.")        return    dist_base = [e['distance'] for e in log_baseline]    power_base = [e['power'] for e in log_baseline]    speed_base = [e['velocity'] for e in log_baseline]    dist_opt = [e['distance'] for e in log_optimized]    power_opt = [e['power'] for e in log_optimized]    speed_opt = [e['velocity'] for e in log_optimized]    elevations = [e['elevation'] for e in log_baseline]     fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 9), sharex=True)    fig.suptitle(f'Comparative Pacing Strategy Analysis - {course_name}', fontsize=16)    ax1.set_title('Power Output and Course Gradient')    ax1.plot(dist_base, power_base, label='Constant Power (Baseline)', color='tab:red', linewidth=2)    ax1.plot(dist_opt, power_opt, label='Optimised (Genetic Algorithm)', color='tab:blue', linewidth=1.5, linestyle='--')    ax1.set_ylabel('Power (Watts)', color='tab:red')    y_limit_max = max(power_opt)*1.2    ax1.set_ylim(0, y_limit_max)    ax1.tick_params(axis='y', labelcolor='tab:red')    ax1.grid(True, which='both', linestyle='--', alpha=0.5)    ax1_twin = ax1.twinx()    ax1_twin.fill_between(dist_base, elevations, 0, color='tab:green', alpha=0.15, label='Grade Area')    ax1_twin.set_ylabel('Elevations (m)', color='tab:green')    ax1_twin.tick_params(axis='y', labelcolor='tab:green')    lines, labels = ax1.get_legend_handles_labels()    lines2, labels2 = ax1_twin.get_legend_handles_labels()    ax1.legend(lines + lines2, labels + labels2, loc='lower right')    ax2.set_title('Speed Comparison (km/h)')    ax2.plot(dist_base, speed_base, label='Constant Speed (Baseline)', color='tab:red', linewidth=2)    ax2.plot(dist_opt, speed_opt, label='Optimised Speed (Genetic Algorithm)', color='tab:blue', linewidth=1.5, linestyle='--')    ax2.set_xlabel('Distance (km)')    ax2.set_ylabel('Speed (km/h)')    ax2.set_ylim(bottom=0)    ax2.legend(loc='lower right')    ax2.grid(True, which='both', linestyle='--', alpha=0.5)    plt.tight_layout(rect=[0, 0.03, 1, 0.95])     filename = 'comparative_performance_profile.png'    plt.show()    print(f"\nSaved plot to '{filename}'")def plot_pacing_strategy_guide(course_name, gpx_track_points, gpx_to_opt_segment_map, optimized_power_profile, rider_ftp, macro_metrics):    import matplotlib.pyplot as plt    from matplotlib.lines import Line2D    if not gpx_track_points or not gpx_to_opt_segment_map or not optimized_power_profile:        print("Warning: Missing data for Pacing Guide.")        return    distances_km = [p['cumulativeDistanceM'] / 1000.0 for p in gpx_track_points]    elevations = [p['smoothedElevation'] for p in gpx_track_points]    target_power_curve = []    for i in range(len(gpx_track_points)):        seg_idx = gpx_to_opt_segment_map[i]        seg_idx = min(seg_idx, len(optimized_power_profile) - 1)        target_power_curve.append(optimized_power_profile[seg_idx])    fig, ax1 = plt.subplots(figsize=(16, 8))    plt.title(f'Rider Pacing Strategy Guide: {course_name}', fontsize=16, fontweight='bold')    color_elev = 'tab:gray'    ax1.set_xlabel('Distance (km)', fontsize=12)    ax1.set_ylabel('Elevation (m)', color=color_elev, fontsize=12)    ax1.fill_between(distances_km, elevations, 0, color=color_elev, alpha=0.2, label='Elevation')    ax1.plot(distances_km, elevations, color=color_elev, linewidth=1.0, alpha=0.5)    ax1.tick_params(axis='y', labelcolor=color_elev)    ax1.grid(True, which='major', axis='x', linestyle='--', alpha=0.5)    ax1.set_xlim(distances_km[0], distances_km[-1])    ax2 = ax1.twinx()    ax2.set_ylabel('Target Power (Watts)', fontsize=12, fontweight='bold')    ax2.plot(distances_km, target_power_curve, color='black', linewidth=2.5, label='Target Power')    def get_zone_color(watts):        pct = watts / rider_ftp        if pct < 0.75: return '#3498db'         elif pct < 1.05: return '#f1c40f'         else: return '#e74c3c'     segment_boundaries = [0]    for i in range(1, len(gpx_track_points)):        if gpx_to_opt_segment_map[i] != gpx_to_opt_segment_map[i-1]:            segment_boundaries.append(i)    segment_boundaries.append(len(gpx_track_points)-1)    for i in range(len(segment_boundaries)-1):        start_idx = segment_boundaries[i]        end_idx = segment_boundaries[i+1]        seg_id = gpx_to_opt_segment_map[start_idx]        seg_id = min(seg_id, len(optimized_power_profile)-1)        watts = optimized_power_profile[seg_id]        grad_str = ""        if seg_id < len(macro_metrics):              grad_val = macro_metrics[seg_id]['avg_gradient']             grad_str = f"\n({grad_val:+.1f}%)"        start_dist = distances_km[start_idx]        end_dist = distances_km[end_idx]        color = get_zone_color(watts)        ax2.fill_between([start_dist, end_dist], 0, [watts, watts], color=color, alpha=0.4)        if (end_dist - start_dist) > 0.3:              mid_dist = (start_dist + end_dist) / 2             label_text = f"{int(watts)}W{grad_str}"             ax2.text(mid_dist, watts + 10, label_text, ha='center', va='bottom', fontsize=9, fontweight='bold', color='black')    max_power = max(optimized_power_profile)    ax2.set_ylim(0, max_power * 1.3)     ftp_label = f"FTP ({int(rider_ftp)}W)"    ax2.axhline(y=rider_ftp, color='gray', linestyle='--', linewidth=1, alpha=0.8, label=ftp_label)    ax2.text(distances_km[0], rider_ftp + 5, ftp_label, color='gray', fontsize=9, ha='left', va='bottom')    lines_1, labels_1 = ax1.get_legend_handles_labels()    lines_2, labels_2 = ax2.get_legend_handles_labels()    custom_lines = [Line2D([0], [0], color='#3498db', lw=4, alpha=0.6),                    Line2D([0], [0], color='#f1c40f', lw=4, alpha=0.6),                    Line2D([0], [0], color='#e74c3c', lw=4, alpha=0.6)]    ax1.legend(lines_1 + lines_2 + custom_lines,                ['Elevation', 'Target Power', ftp_label, 'Easy (Z1-2)', 'Threshold (Z3-4)', 'VO2 Max (Z5+)'],                loc='upper left', bbox_to_anchor=(1.08, 1), borderaxespad=0.)    plt.tight_layout()     plt.savefig('rider_pacing_strategy.png', dpi=150)     print("\n--- Saved Rider Strategy Plot to 'rider_pacing_strategy.png' ---")    plt.show()def run_selected_optimization(optimization_type: str, rider_params: Dict, sim_params: Dict, course_data: Dict, progress_bar=None) -> Tuple[float, float, List[float], List[Dict], str, List[Dict], List[float]]:     gpx_track_points = course_data['gpx_track_points']    total_course_distance_m = course_data['total_course_distance_m']    rider_target_power_watts = rider_params['rider_target_power_watts']    final_time = float('inf')    avg_power = 0.0    final_power_profile_full_gpx = []    final_simulation_log = []    strategy_display_name = ""    macro_segment_metrics_output = []    avg_macro_segment_gradients = []     optimized_macro_profile = []     if 'gpx_to_opt_segment_map' in course_data:        gpx_to_opt_segment_map = course_data['gpx_to_opt_segment_map']        avg_macro_segment_gradients = course_data['avg_macro_segment_gradients']        num_dynamic_segments = course_data['num_dynamic_segments']    else:        gpx_to_opt_segment_map, avg_macro_segment_gradients, num_dynamic_segments = gpx_tool.get_macro_segment_data(            gpx_track_points, total_course_distance_m, rider_params=rider_params        )    print("\n--- Dynamically Determined Terrain Segments ---")    print(f"Total Segments Found: {num_dynamic_segments}")    print("---------------------------------------------\n")    if optimization_type == "constant_ftp":        strategy_display_name = "Constant Power Pacing (Baseline)"        constant_ftp_profile = [rider_target_power_watts] * len(gpx_track_points)        final_time, avg_power, final_simulation_log, _ = physics_engine.simulate_course(            rider_params['rider_mass'], rider_params['bike_mass'], rider_params['cda'],            rider_params['mechanical_efficiency'],            sim_params['starting_elevation_m'], sim_params['global_wind_speed_kmh'],             sim_params['global_wind_direction_from_deg'],            sim_params['ambient_temperature_celsius'],            sim_params['enable_cornering_model'], sim_params['friction_coefficient_mu'],             sim_params['rider_skill_factor'],            sim_params['surface_profile'],            gpx_track_points, total_course_distance_m,            constant_ftp_profile,            gpx_to_opt_segment_map,            report_progress=True,            rider_ftp=rider_params['rider_ftp_watts'],            rider_w_prime=rider_params['w_prime_capacity_j'] # [CHANGE 3]         )        final_power_profile_full_gpx = constant_ftp_profile        optimized_macro_profile = [rider_target_power_watts] * num_dynamic_segments         macro_segment_metrics_output = gpx_tool.calculate_macro_segment_metrics(            final_simulation_log, num_dynamic_segments, optimized_macro_profile, avg_macro_segment_gradients, total_course_distance_m        )    elif "greedy" in optimization_type:        if optimization_type == "greedy_quick":            strategy_display_name = "Quick Optimisation (Greedy Hill Climbing)"            greedy_params = {                'optimization_attempts': optimizer.GREEDY_QUICK_ATTEMPTS,                 'power_swap_ftp_factor': optimizer.GREEDY_POWER_SWAP_FTP_FACTOR,                'no_improvement_threshold': optimizer.GREEDY_NO_IMPROVEMENT_THRESHOLD            }            initial_profile = "constant_ftp"        else:             strategy_display_name = "Moderate Optimisation (Greedy Hill Climbing)"            greedy_params = {                'optimization_attempts': optimizer.GREEDY_MODERATE_ATTEMPTS,                 'power_swap_ftp_factor': optimizer.GREEDY_POWER_SWAP_FTP_FACTOR,                'no_improvement_threshold': optimizer.GREEDY_NO_IMPROVEMENT_THRESHOLD * 5            }            initial_profile = "constant_ftp"        final_time, final_power_profile_full_gpx, _, optimized_macro_profile, final_simulation_log = optimizer.optimize_pacing_greedy_hill_climbing(            rider_params, sim_params, course_data, greedy_params, num_segments=num_dynamic_segments, initial_profile_type=initial_profile        )        if final_time != float('inf'):            _, avg_power, _, _ = physics_engine.simulate_course(                rider_params['rider_mass'], rider_params['bike_mass'], rider_params['cda'],                rider_params['mechanical_efficiency'],                sim_params['starting_elevation_m'], sim_params['global_wind_speed_kmh'],                 sim_params['global_wind_direction_from_deg'],                sim_params['ambient_temperature_celsius'],                sim_params['enable_cornering_model'], sim_params['friction_coefficient_mu'],                 sim_params['rider_skill_factor'],                sim_params['surface_profile'],                gpx_track_points, total_course_distance_m,                final_power_profile_full_gpx,                gpx_to_opt_segment_map,                report_progress=False,                rider_ftp=rider_params['rider_ftp_watts'],                rider_w_prime=rider_params['w_prime_capacity_j'] # [CHANGE 3]            )        macro_segment_metrics_output = gpx_tool.calculate_macro_segment_metrics(            final_simulation_log, num_dynamic_segments, optimized_macro_profile, avg_macro_segment_gradients, total_course_distance_m        )    elif optimization_type == "genetic_algorithm":        strategy_display_name = "Advanced Optimisation (Genetic Algorithm)"        ga_params = {            'population_size': optimizer.GA_POPULATION_SIZE,            'num_generations': optimizer.GA_NUM_GENERATIONS,            'mutation_rate': optimizer.GA_MUTATION_RATE,            'crossover_rate': optimizer.GA_CROSSOVER_RATE,            'elitism_count': optimizer.GA_ELITISM_COUNT,            'mutation_ftp_factor': optimizer.GA_MUTATION_FTP_FACTOR        }        final_time, final_power_profile_full_gpx, _, optimized_macro_profile, avg_macro_segment_gradients_ga, final_simulation_log = optimizer.optimize_pacing_ga(            rider_params, sim_params, course_data, ga_params, num_segments=num_dynamic_segments, progress_bar=progress_bar        )        if final_time != float('inf'):             _, avg_power, _, _ = physics_engine.simulate_course(                rider_params['rider_mass'], rider_params['bike_mass'], rider_params['cda'],                rider_params['mechanical_efficiency'],                sim_params['starting_elevation_m'], sim_params['global_wind_speed_kmh'],                 sim_params['global_wind_direction_from_deg'],                sim_params['ambient_temperature_celsius'],                sim_params['enable_cornering_model'], sim_params['friction_coefficient_mu'],                 sim_params['rider_skill_factor'],                sim_params['surface_profile'],                gpx_track_points, total_course_distance_m,                final_power_profile_full_gpx,                gpx_to_opt_segment_map,                report_progress=False,                rider_ftp=rider_params['rider_ftp_watts'],                rider_w_prime=rider_params['w_prime_capacity_j'] # [CHANGE 3]            )        macro_segment_metrics_output = gpx_tool.calculate_macro_segment_metrics(            final_simulation_log, num_dynamic_segments, optimized_macro_profile, avg_macro_segment_gradients_ga, total_course_distance_m        )        avg_macro_segment_gradients = avg_macro_segment_gradients_ga         else:        print("Invalid optimisation type selected.")        return float('inf'), 0.0, [], [], "N/A", [], []         return final_time, avg_power, final_power_profile_full_gpx, final_simulation_log, strategy_display_name, macro_segment_metrics_output, avg_macro_segment_gradients, optimized_macro_profiledef run_comparative_test(num_runs: int, rider_params: Dict, sim_params: Dict, course_data: Dict, run_greedy_quick: bool, run_greedy_moderate: bool, run_genetic: bool, progress_bar=None):    print(f"\n--- Running Comparative Test for {num_runs} Run(s) ---")    all_times = {"Constant": []}          all_avg_powers = {"Constant": []}     all_avg_speeds = {"Constant": []}     all_improvements = {}                 strategy_map = {"Constant": "constant_ftp"}    strategies_to_run = ["Constant"]     final_genetic_profile = None     final_genetic_gradients = None     final_genetic_metrics = None     final_optimized_time_seconds = None    final_constant_log = None             final_optimized_log = None    if run_greedy_quick:        strategy_map["Greedy Q"] = "greedy_quick"        strategies_to_run.append("Greedy Q")        all_times["Greedy Q"] = []        all_avg_powers["Greedy Q"] = []        all_avg_speeds["Greedy Q"] = []        all_improvements["Greedy Q"] = []    if run_greedy_moderate:        strategy_map["Greedy M"] = "greedy_moderate"        strategies_to_run.append("Greedy M")        all_times["Greedy M"] = []        all_avg_powers["Greedy M"] = []        all_avg_speeds["Greedy M"] = []        all_improvements["Greedy M"] = []    if run_genetic:        final_genetic_profile = None         final_genetic_gradients = None        strategy_map["Genetic"] = "genetic_algorithm"        strategies_to_run.append("Genetic")        all_times["Genetic"] = []        all_avg_powers["Genetic"] = []        all_avg_speeds["Genetic"] = []        all_improvements["Genetic"] = []    for run_idx in range(num_runs):        print(f"\nRun {run_idx + 1}/{num_runs}...")        current_course_data = course_data.copy()        constant_ftp_time, constant_avg_power, _, constant_sim_log, _, _, _, _ = run_selected_optimization(            strategy_map["Constant"], rider_params, sim_params, current_course_data        )        final_constant_log = constant_sim_log        plot_performance_profile(constant_sim_log, "Baseline: Constant Power")        all_times["Constant"].append(constant_ftp_time)        all_avg_powers["Constant"].append(constant_avg_power)        if constant_ftp_time != float('inf'):            avg_speed = physics_engine.calculate_average_speed_kmh(current_course_data['total_course_distance_m'] / 1000, constant_ftp_time)            all_avg_speeds["Constant"].append(avg_speed)        else:            all_avg_speeds["Constant"].append(0)         for strategy_name in strategies_to_run:            if strategy_name == "Constant": continue             opt_type = strategy_map[strategy_name]            current_time, current_avg_power, _, current_sim_log, _, current_metrics, gradients, macro_profile = run_selected_optimization(                opt_type, rider_params, sim_params, current_course_data, progress_bar=progress_bar if strategy_name == "Genetic" else None             )            all_times[strategy_name].append(current_time)            all_avg_powers[strategy_name].append(current_avg_power)            if strategy_name == "Genetic":                  plot_performance_profile(current_sim_log, "Optimised: Genetic Algorithm")                 final_genetic_profile = macro_profile                 final_genetic_gradients = gradients                 final_genetic_metrics = current_metrics                  final_optimized_log = current_sim_log                 final_optimized_time_seconds = current_time            if current_time != float('inf'):                avg_speed = physics_engine.calculate_average_speed_kmh(current_course_data['total_course_distance_m'] / 1000, current_time)                all_avg_speeds[strategy_name].append(avg_speed)                improvement = constant_ftp_time - current_time                all_improvements[strategy_name].append(improvement)            else:                all_avg_speeds[strategy_name].append(0)                all_improvements[strategy_name].append(float('-inf'))    print("\n--- Comparative Test Results Summary ---")    print(f"Course: {course_data['name']} ({course_data['total_course_distance_m'] / 1000:.2f} km)")    print(f"Adjusted Power Target: {rider_params['rider_target_power_watts']:.1f} Watts")    print("\nStrategy | Avg Time | Best Time | Avg Speed | Avg Power | Improvement (vs. Const)")    print("---------|----------|-----------|-----------|-----------|-------------------------")    for strategy_name in strategies_to_run:        times = [t for t in all_times[strategy_name] if t != float('inf')]        powers = [p for p in all_avg_powers[strategy_name] if p > 0]        speeds = [s for s in all_avg_speeds[strategy_name] if s > 0]        avg_time = statistics.mean(times) if times else float('inf')        best_time = min(times) if times else float('inf')        avg_power_val = statistics.mean(powers) if powers else 0.0        avg_speed_val = statistics.mean(speeds) if speeds else 0.0        avg_time_str = f"{physics_engine.format_time_hms(avg_time)[1]:02d}m {physics_engine.format_time_hms(avg_time)[2]:02d}s" if avg_time != float('inf') else "Incomplete"        best_time_str = f"{physics_engine.format_time_hms(best_time)[1]:02d}m {physics_engine.format_time_hms(best_time)[2]:02d}s" if best_time != float('inf') else "Incomplete"        avg_speed_str = f"{avg_speed_val:.2f} km/h"        avg_power_str = f"{avg_power_val:.1f} W"        improvement_str = "N/A"        if strategy_name != "Constant":            improvements = [imp for imp in all_improvements[strategy_name] if imp != float('-inf')]            if improvements:                avg_improvement = statistics.mean(improvements)                avg_imp_m = int(avg_improvement // 60)                avg_imp_s = int(abs(avg_improvement) % 60)                avg_imp_sign = "+" if avg_improvement > 0 else "-" if avg_improvement < 0 else ""                improvement_str = f"{avg_imp_sign}{avg_imp_m:02d}m {avg_imp_s:02d}s"            else:                improvement_str = "N/A"        print(f"{strategy_name:<9}| {avg_time_str:<9}| {best_time_str:<10}| {avg_speed_str:<10}| {avg_power_str:<10}| {improvement_str:<23}")    if final_genetic_profile and final_genetic_gradients:        if final_optimized_time_seconds is not None:             course_data['macro_segment_metrics'] = final_genetic_metrics             generate_rider_report(                 rider_params,                 course_data,                 final_genetic_profile,                  final_optimized_time_seconds              )             plot_pacing_strategy_guide(                     course_data['name'],                      course_data['gpx_track_points'],                     course_data['gpx_to_opt_segment_map'],                     final_genetic_profile,                     rider_params['rider_ftp_watts'],                     final_genetic_metrics                 )        print("\n--- Final Optimised Pacing Strategy (Genetic Algorithm) ---")        print("Segment | Avg Gradient (%) | Optimised Power (W)")        print("--------|------------------|---------------------")        for i, (power, grad) in enumerate(zip(final_genetic_profile, final_genetic_gradients)):            print(f"{i+1:<8}| {grad:^16.2f} | {power:^19.1f}")    if final_constant_log and final_optimized_log:        plot_comparative_performance(final_constant_log, final_optimized_log, course_data['name'])def estimate_ride_duration(rider_params: Dict, sim_params: Dict, course_data: Dict) -> float:    if not course_data.get('gpx_track_points'):        print("Warning: Cannot estimate duration without GPX track points.")        return float('inf')    constant_power_profile = [rider_params['rider_ftp_watts']] * len(course_data['gpx_track_points'])    estimated_time, _, _, _ = physics_engine.simulate_course(         rider_params['rider_mass'], 	rider_params['bike_mass'], 	rider_params['cda'],        rider_params['mechanical_efficiency'], 	sim_params['starting_elevation_m'],        sim_params['global_wind_speed_kmh'], 	sim_params['global_wind_direction_from_deg'],        sim_params['ambient_temperature_celsius'],        sim_params['enable_cornering_model'], 	sim_params['friction_coefficient_mu'],        sim_params['rider_skill_factor'], 	sim_params['surface_profile'],        course_data['gpx_track_points'], 	course_data['total_course_distance_m'],        constant_power_profile,        gpx_to_opt_segment_map=None,         report_progress=False,        rider_ftp=rider_params['rider_ftp_watts'],        rider_w_prime=rider_params['w_prime_capacity_j'] # [CHANGE 3]     )    return estimated_timedef adjust_power_for_duration(base_ftp: float, estimated_duration_seconds: float, w_prime_j: float) -> float:    # [CHANGE 3] Now accepts w_prime_j as argument instead of hardcoded 14000    if estimated_duration_seconds == float('inf') or estimated_duration_seconds <= 0:        return base_ftp * 0.8         anaerobic_contribution_watts = w_prime_j / estimated_duration_seconds    max_sustainable_power = base_ftp + anaerobic_contribution_watts    target_power = max_sustainable_power * 0.96    print(f"    [Honesty Check] Estimated Duration: {estimated_duration_seconds/60:.1f} min")    print(f"    [Honesty Check] FTP: {base_ftp:.1f}W, Anaerobic Contribution: +{anaerobic_contribution_watts:.1f}W (W'={w_prime_j}J)")    print(f"    [Honesty Check] Honest Baseline Target: {target_power:.1f}W")    return target_powerdef generate_rider_report(rider_params: Dict, course_data: Dict, optimized_power_profile: List[float], optimized_time: float):    rider_ftp = rider_params['rider_ftp_watts']    macro_segment_data = course_data['macro_segment_metrics']    if isinstance(macro_segment_data, tuple):        macro_segment_metrics_list = macro_segment_data[0]    else:        macro_segment_metrics_list = macro_segment_data    num_profile_segments = len(optimized_power_profile)    num_data_segments = len(macro_segment_metrics_list)    num_segments = min(num_profile_segments, num_data_segments)    time_hour, time_min, time_sec = physics_engine.format_time_hms(optimized_time)[0:]    print("\n" + "="*80)    print(f"FINAL OPTIMISATION REPORT - Course Time: {time_hour}h {time_min}m {time_sec}s")    print(f"Rider FTP: {rider_ftp:.1f}W")    print("="*80)    print("#   | Start (km) | End (km) | Dist (m) | Avg Grad | Power (W) | Zone")    print("-" * 80)    for i in range(num_segments):        power_watts = optimized_power_profile[i]        segment_details = macro_segment_metrics_list[i]        try:            if not isinstance(segment_details, dict):                if isinstance(segment_details, (list, tuple)) and len(segment_details) > 0 and isinstance(segment_details[0], dict):                    segment_details = segment_details[0]                 else:                    raise TypeError("Segment data is neither a dictionary nor an unpackable container of a dictionary.")        except TypeError as e:            print(f"{i+1:<3} | -- ERROR --| -- ERROR -- | -- ERROR -- | -- ERROR -- | -- ERROR -- | Data type error at index {i}. SKIPPED. ({e})")            continue        power_zone = optimizer.get_power_zone(power_watts, rider_ftp)         print(            f"{i+1:<3} | "            f"{segment_details['segment_start_km']:<10.2f} | "            f"{segment_details['segment_end_km']:<8.2f} | "            f"{segment_details['actual_distance_km'] * 1000.0:<8.0f} | "            f"{segment_details['avg_gradient']:<8.1f} | "            f"{power_watts:<9.1f} | "            f"{power_zone:<30}"        )    print("="*80)def calculate_power_from_target_time(target_time_seconds: float, rider_params: Dict, sim_params: Dict, course_data: Dict) -> float:    low_bound_watts = 50.0       high_bound_watts = 9999.9     tolerance_seconds = 1.0      sim_rider = rider_params.copy()    for _ in range(20):        guess_watts = (low_bound_watts + high_bound_watts) / 2.0        guess_profile = [guess_watts] * len(course_data['gpx_track_points'])        sim_time, _, _, _ = physics_engine.simulate_course(             sim_rider['rider_mass'], sim_rider['bike_mass'], sim_rider['cda'],             sim_rider['mechanical_efficiency'],              sim_params['starting_elevation_m'], sim_params['global_wind_speed_kmh'],              sim_params['global_wind_direction_from_deg'], sim_params['ambient_temperature_celsius'],             sim_params['enable_cornering_model'], sim_params['friction_coefficient_mu'],             sim_params['rider_skill_factor'], sim_params['surface_profile'],             course_data['gpx_track_points'], course_data['total_course_distance_m'],             guess_profile,              gpx_to_opt_segment_map=None,               report_progress=False,             rider_ftp=guess_watts,             rider_w_prime=rider_params['w_prime_capacity_j'] # [CHANGE 3]        )        if sim_time == float('inf'):            low_bound_watts = guess_watts        elif abs(sim_time - target_time_seconds) < tolerance_seconds:            return guess_watts         elif sim_time > target_time_seconds:            low_bound_watts = guess_watts        else:            high_bound_watts = guess_watts    return guess_wattsdef main():    print("Script execution started...")    start_time_script = time.time()    MANUAL_SEGMENT_BOUNDARIES_KM = []    RUN_GREEDY_QUICK = False    RUN_GREEDY_MODERATE = False    RUN_GENETIC_ALGORITHM = True    print("\n--- Loading Configuration ---")    try:        with open('config.json', 'r') as f:            config = json.load(f)    except FileNotFoundError:        print("Error: 'config.json' not found.")        return    rider_settings = config['rider_settings']    rider_params = {        'rider_ftp_watts': rider_settings['rider_ftp_watts'],        'rider_mass': rider_settings['rider_mass_kg'],        'bike_mass': rider_settings['bike_mass_kg'],        'cda': rider_settings['cda_m2'],        'mechanical_efficiency': rider_settings['mechanical_efficiency'],        'w_prime_capacity_j': rider_settings.get('w_prime_capacity_j', 14000.0) # [CHANGE 3] Load from config or default    }    course_settings = config['course_settings']    sim_settings = config['simulation_settings']    sim_params = {        'global_wind_speed_kmh': course_settings['global_wind_speed_kmh'],        'global_wind_direction_from_deg': course_settings['global_wind_direction_from_deg'],        'ambient_temperature_celsius': course_settings['ambient_temperature_celsius'],        'surface_profile': sim_settings['surface_profile_crr'],        'enable_cornering_model': sim_settings['enable_cornering_model'],        'friction_coefficient_mu': sim_settings['friction_coefficient_mu'],        'rider_skill_factor': sim_settings['rider_skill_factor'],        'starting_elevation_m': sim_settings['starting_elevation_m'],        'gpx_filename': course_settings['gpx_filename']    }    opt_settings = config['optimization_settings']    RUN_GREEDY_QUICK = opt_settings['run_greedy_quick']    RUN_GREEDY_MODERATE = opt_settings['run_greedy_moderate']    RUN_GENETIC_ALGORITHM = opt_settings['run_genetic_algorithm']    sim_params['ga_population_size'] = opt_settings['ga_population_size']    sim_params['ga_num_generations'] = opt_settings['ga_num_generations']    print(f"--- Processing GPX File: {sim_params['gpx_filename']} ---")    gpx_result_dict = gpx_tool.parse_gpx_file(    sim_params['gpx_filename'],     auto_downsample=USE_SMART_DOWNSAMPLING)    gpx_track_points = gpx_result_dict['trackPoints']        # [CHANGE 2] Pre-calculate Crr for O(1) Lookup    gpx_tool.enrich_track_with_surface_profile(gpx_track_points, sim_params['surface_profile'])        total_course_distance_m = gpx_result_dict['totalDistanceKm'] * 1000    plot_data = gpx_result_dict['plot_data']    course_data = {        'name': gpx_result_dict['name'],        'gpx_track_points': gpx_track_points,        'total_course_distance_m': total_course_distance_m,        'total_elevation_gain_m': gpx_tool.calculate_total_ascent(gpx_track_points)    }    print("\n--- Calculating Course Segmentation ---")    start_time_segmentation = time.time()    gpx_to_opt_segment_map, avg_macro_segment_gradients, num_dynamic_segments = gpx_tool.get_macro_segment_data(        gpx_track_points,        total_course_distance_m,        rider_params=rider_params,        manual_boundaries_km=MANUAL_SEGMENT_BOUNDARIES_KM     )    end_time_segmentation = time.time()    print(f"*** Segmentation Calculation Time: {end_time_segmentation - start_time_segmentation:.2f} seconds ***")    course_data['gpx_to_opt_segment_map'] = gpx_to_opt_segment_map    course_data['avg_macro_segment_gradients'] = avg_macro_segment_gradients    course_data['num_dynamic_segments'] = num_dynamic_segments    plot_segments_on_profile(gpx_track_points, gpx_to_opt_segment_map, course_data['name'])    print("\n--- Power Target Adjustment for Ride Duration ---")    base_rider_ftp_watts = rider_params['rider_ftp_watts']    estimated_time_s = estimate_ride_duration(rider_params, sim_params, course_data)    if estimated_time_s != float('inf'):        estimated_minutes = int(estimated_time_s // 60)        estimated_seconds = int(estimated_time_s % 60)        print(f"  > Estimated ride duration at base FTP: {estimated_minutes}m {estimated_seconds}s.")        # [CHANGE 3] Pass w_prime        adjusted_target_power = adjust_power_for_duration(            base_rider_ftp_watts, estimated_time_s, rider_params['w_prime_capacity_j']        )        total_mass = rider_params['rider_mass'] + rider_params['bike_mass']        w_per_kg = adjusted_target_power / total_mass        print("Step 2: Adjusting average power target based on this duration.")        print(f"  > Original 1-hour FTP: {base_rider_ftp_watts:.1f} W")        print(f"  > Adjusted Power Target for this effort: {adjusted_target_power:.1f} W (~{w_per_kg:.2f} W/kg)")        rider_params['rider_target_power_watts'] = adjusted_target_power     else:        print("  > Could not estimate ride duration. Using original FTP.")        rider_params['rider_target_power_watts'] = base_rider_ftp_watts     print("-------------------------------------------------")    total_mass = rider_params['rider_mass'] + rider_params['bike_mass']    print("\n--- Cycling Time Trial Prediction (Dynamic Simulation) ---")    print(f"Course Name: {course_data['name']}")    print(f"Total Smoothed Elevation Gain: {course_data['total_elevation_gain_m']:.1f} m")    print(f"Adjusted Rider Power Target: {rider_params['rider_target_power_watts']:.1f} Watts")    print(f"Rider Mass: {rider_params['rider_mass']} kg, Bike Mass: {rider_params['bike_mass']} kg (Total: {total_mass} kg)")    print(f"Starting Elevation: {sim_params['starting_elevation_m']:.0f} meters")    print(f"Global Wind: {sim_params['global_wind_speed_kmh']:.1f} km/h from {sim_params['global_wind_direction_from_deg']:.1f}Â°")    NUM_COMPARATIVE_RUNS = 1     run_comparative_test(        NUM_COMPARATIVE_RUNS,        rider_params,        sim_params,        course_data,        run_greedy_quick=RUN_GREEDY_QUICK,        run_greedy_moderate=RUN_GREEDY_MODERATE,        run_genetic=RUN_GENETIC_ALGORITHM    )    print("\n--- Testing Web Feature: Time -> Power Calculator ---")    best_time_seconds = estimate_ride_duration(rider_params, sim_params, course_data)    target_time_s = best_time_seconds - 30.0     target_min = int(target_time_s // 60)    target_sec = int(target_time_s % 60)    print(f"Goal: Finish in {target_min}m {target_sec}s (30s faster than constant power)")    required_watts = calculate_power_from_target_time(target_time_s, rider_params, sim_params, course_data)    print(f"Solver Result: To hit {target_min}m {target_sec}s, you need to hold {required_watts:.1f} Watts.")    print("-------------------------------------------------")    end_time_script = time.time()    duration = end_time_script - start_time_script    minutes = int(duration // 60)    seconds = int(duration % 60)    print(f"\nTotal script execution time: {minutes}m {seconds}s")if __name__ == "__main__":    main()